Number theory
====

Number theory is useful in building:

* Key exchange protocols
* Digital signatures
* Public key encryption

Further reading: A Computational Introduction to Number Theory and Algebra by Victor Shoup - [Free PDF](http://shoup.net/ntb/). In particular, chapters 1-4, 11, 12

**Notation**:

* N - positive integer
* p - prime number
* ‚Ñ§<sub>N</sub> - {0, 1, ..., N-1}. Its a ring where addition and multiplication are done modulo-N

**GCD**:

* gcd(x, y) denotes the greatest common divisor of x and y.
* For all integers x, y ‚àÉ a, b s.t. a.x + b.y = gcd(x, y)
* a, b can be found efficiently using the [Extended Euclid Algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers). Running time is O(n<sup>2</sup>) where n is the number of bits of N
* If gcd(x, y) = 1, x and y are relatively prime

**Modular inversion**:

* The inverse of an element x in ‚Ñ§<sub>N</sub> is y s.t. xy = 1 in ‚Ñ§<sub>N</sub>
* y is denotes by x<sup>-1</sup>
* Lemma: x in ‚Ñ§<sub>N</sub> has an inverse iff gcd(x, N) = 1
* If x is relatively prime to N, use the equation from above a.x + b.N = 1 and find a, b using EEA. a is the inverse of x
* It is trivial to solve linear equations a.x + b = 0 modulo N. x = -b.a<sup>-1</sup>

**‚Ñ§<sub>N</sub><sup>* </sup>**:

* Set of invertible elements in ‚Ñ§<sub>N</sub>
* For a prime number, all elements in ‚Ñ§<sub>N</sub> are relatively prime. Hence the |‚Ñ§<sub>N</sub><sup>* </sup>| = p - 1 (0 not counted)

---

#### Fermat and Euler

**Fermat's little theorem**:

* ‚àÄ x ‚àà ‚Ñ§<sub>p</sub><sup>* </sup>: x<sup>p-1</sup> = 1 in ‚Ñ§<sub>p</sub>
* Example. p=5. 3<sup>5-1</sup> = 81 = 1 in ‚Ñ§<sub>5</sub>
* Implication of FLT: x<sup>p-1</sup> = 1 in ‚Ñ§<sub>p</sub> => x.x<sup>p-2</sup> = 1 => x<sup>-1</sup> = x<sup>p-2</sup> in ‚Ñ§<sub>p</sub>. This method is less efficient than EEA and it only works modulo-primes.
* Application of FLT: To generate a large prime, say of 1024 bits. Choose a random number p between 2<sup>1024</sup> and 2<sup>1025</sup>-1. Test if 2<sup>p-1</sup>=1 in ‚Ñ§<sub>p</sub>. If so, output p. This is a simple algo to generate primes, but there is a small probability (2<sup>-60</sup>) that a composite can be generated

**Euler's work on ‚Ñ§<sub>p</sub><sup>* </sup>**:

* It is a cyclic group, meaning that ‚àÉ g ‚àà ‚Ñ§<sub>p</sub><sup>* </sup> such that {1, g, g<sup>2</sup>, ..., g<sup>p-2</sup>} = (‚Ñ§<sub>p</sub><sup>* </sup> ).
* g is called the generator of ‚Ñ§<sub>p</sub><sup>* </sup>. Obviously, g<sup>p-1</sup> = 1 from Fermat's theorem.
* Not ever element in ‚Ñ§<sub>p</sub><sup>* </sup> is a generator

**Order**:

* For ‚àÄ g ‚àà ‚Ñ§<sub>p</sub><sup>* </sup> the set {1, g, g<sup>2</sup>, ...} is called the group generated by g.
* The order of g ‚àà ‚Ñ§<sub>p</sub><sup>* </sup> is the size of the group.
* The order of g is the smallest number a > 0 s.t. g<sup>a</sup> = 1 in ‚Ñ§<sub>p</sub>

**Lagrange's theorem**:

* ‚àÄ g ‚àà ‚Ñ§<sub>p</sub><sup>* </sup>: ord<sub>p</sub>(g) divides p-1.
* Fermat's theorem follows directly from Lagrange's theorem.

**Euler's generalisation of Fermat's theorem**:
* For an integer N we define ùúë(N) = |‚Ñ§<sub>N</sub><sup>* </sup>| then ùúë(p) = p-1.
* Also - for a number that's a product of 2 primes N = p.q, ùúë(N) = N - p - q + 1 (all the numbers in N minus the ones that aren't relatively prime to N, ie, divisible by p or divisible by q plus 1) = (p-1)(q-1)
* Euler's theorem - ‚àÄ x ‚àà ‚Ñ§<sub>N</sub><sup>* </sup>: x<sup>ùúë(N)</sup> = 1 in ‚Ñ§<sub>N</sub>. If N was prime p, we would simply write x<sup>p-1</sup> = 1 in ‚Ñ§<sub>p</sub>, which is FLT.

---

#### Modular e'th roots:

* For a linear equation a.x + b = 0 in ‚Ñ§<sub>p</sub>, x = -b.a<sup>-1</sup>
* Objective - solving higher degree polynomials - x<sup>2</sup> - c = 0 and y<sup>3</sup> - c = 0 and z<sup>37</sup> - c = 0 in ‚Ñ§<sub>p</sub>
* Defintion - x ‚àà ‚Ñ§<sub>p</sub> s.t. x<sup>e</sup> = c in ‚Ñ§<sub>p</sub> is called the e'th root of c
* The e'th root doesn't always exist. When does it exist? Can we compute it efficiently?
* Easy case: Suppose gcd(e, p-1) = 1. Then for all ‚àÄ c ‚àà ‚Ñ§<sub>p</sub><sup>* </sup>: e<sup>1/e</sup> exists in ‚Ñ§<sub>p</sub><sup>* </sup> and is easy to find.
* Hard case:
* Solving quadratic equations mod p: a.x<sup>2</sup> + b.x + c = 0 in ‚Ñ§<sub>p</sub>.
  * Solution: x = (-b +- sqrt(b<sup>2</sup> - 4.a.c))/2.a in ‚Ñ§<sub>p</sub>
  * Find (2.a)<sup>-1</sup> using extended Euclid
  * Find sqrt(b<sup>2</sup> - 4.a.c) using one of the square root algorithms
* Computing c<sup>1/e</sup> in ‚Ñ§<sub>N</sub> requires the factorisation of N, as far as we know

---

#### Arithmetic Algorithms

* To represent an n-bit integer on a 64-bit machine, it is broken into n/32 32-bit blocks. Some processors have 128-bit registers. The size of each block is kept half the size of the processor's register size so that the result after multiplication can fit in the register
* Addition and subtraction of 2 n-bit integers - O(n)
* Naive multiplication algorithm - O(n<sup>2</sup>). There are better algos - O(n<sup>1.585</sup>) [Karatsuba], O(n.lg(n)). Karatsuba's algo is preferred in most crypto libraries.
* Division with remainder - O(n<sup>2</sup>)
* Exponentiation - by Repeated squaring. To find g<sup>53</sup>, we calculate g<sup>2</sup>, g<sup>4</sup>, g<sup>8</sup>, g<sup>16</sup> and then find g<sup>32</sup>.g<sup>16</sup>.g<sup>4</sup>.g<sup>1</sup>. To calculate g<sup>x</sup>, it takes O(log<sub>2</sub>(x)), so to calculate the entire exponent, it takes O(log(x).n<sup>2</sup>) <= O(n<sup>3</sup>)

---

#### Intractable Problems:

**Some easy problems**:

* Given N and x in ‚Ñ§<sub>N</sub>, find x<sup>-1</sup> in ‚Ñ§<sub>N</sub>
* Given p and polynomial f(x) in ‚Ñ§<sub>p</sub>[x] find x in ‚Ñ§<sub>p</sub> such that f(x) = 0 in ‚Ñ§<sub>p</sub>. Running time is linear in deg(f)

**Intractable problems with primes**

* Fix a prime p > 2 and g in ‚Ñ§<sub>p</sub><sup>* </sup> of order q
* Consider the function x ->  g<sup>x</sup> in ‚Ñ§<sub>p</sub>
* Now consider the inverse function Dlog<sub>g</sub>(g<sup>x</sup>) = x where x in {0, 1, ..., q-2}
* This is extremely difficult to compute for large primes
* In general, it doesn't have to apply only to the cyclic group ‚Ñ§<sub>p</sub><sup>* </sup>. We can define it more formally:
  * Consider a finite cyclic group G, where g is a generator of G. So G = {1, g, g<sup>2</sup>,..., g<sup>q-1</sup>}
  * We say DLOG is hard in G if for all efficient algorithms A, Pr<sub>g<-G, x<-Z<sub>q</sub></sub>[A(G, q, g, g<sup>x</sup>) = x] < negligible
* Examples:
  * ‚Ñ§<sub>p</sub><sup>* </sup> for large p. Complexity exp(O(cubrt(n))).
  * elliptic curve groups mod p. Complexity exp(n/2)

**Intractable problems with composites**

* Consider the set of integers ‚Ñ§<sub>2</sub>(n) = {N = p.q where p,q are n-bit primes}
* Problem 1: Factor a random N in ‚Ñ§<sub>2</sub>(n). This is considered hard for n = 2048
* Problem 2: Given a polynomial f(x) where degree(f) > 1 and a random N in ‚Ñ§<sub>2</sub>(n) find x in ‚Ñ§<sub>N</sub> such that f(x) = 0 in ‚Ñ§<sub>N</sub>. (RSA is based on this)

Testing the primality of a number is easy - both deterministic and randomised algorithms for this exist. Factorising a composite into its prime factors is more difficult.
